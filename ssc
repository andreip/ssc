#!/usr/bin/ruby

require 'net/http'
require 'xml/smart'
require 'cgi'
require 'fileutils'
require 'optparse'


$server_name="susestudio.com"
$api_prefix="api/v1/user"
$username=""
$password=""
force = false
follow = false
images = false
version="0.1"

def get_appliance_from_args_or_config args
  if args
    appliance = args[1]
  end
  unless appliance
    if File.exists?(".ssc/appliance.config")
      appliance_config = XML::Smart.open(".ssc/appliance.config")
      appliance = appliance_config.find("/checkout/appliance_id").first.to_s if appliance_config.find("/checkout/appliance_id").length > 0
    end
  end
  if appliance.nil? || appliance.empty?
    STDERR.puts "You need to specify an appliance."
    exit 1
  end
  appliance
end

class Request
  attr_accessor :method, :call, :data

  def go
    uri = URI.parse("http://#{$server_name}/#{$api_prefix}/#{call}")
    request = nil
    if method == "GET"
      request = Net::HTTP::Get.new(uri.request_uri)
    elsif method == "POST"
      request = Net::HTTP::Post.new(uri.request_uri)
      request.set_form_data(data, ";") unless data.nil?
    elsif method == "DELETE"
      request = Net::HTTP::Delete.new(uri.request_uri)
    end
    request.basic_auth($username, $password)
    begin
      Net::HTTP.start(uri.host, uri.port) do |http|
        http.read_timeout = 45
        response = http.request(request)
        unless( response.kind_of? Net::HTTPSuccess )
          return [response.body, false]
        end
        return [response.body, true]
      end
    rescue => e
      return ["Error: #{e.to_s}", false]
    end
  end
end

class CommandHandler
   def self.doRequest r
    xml, success = r.go
    if success
     return xml
    else
      handle_error xml
    end
   end

  def self.handle_error s
    xml = XML::Smart.string(s)
    if xml.find("/error/code").length > 0
      STDERR.puts "Error '#{xml.find("/error/code").first.to_s}' occured.\nMessage: #{xml.find("/error/message").first.to_s}"
    else
      STDERR.puts "Server returned: #{s}"
    end
    exit 1
  end

  def self.download_file url, target
    uri = URI.parse(url)
    request = Net::HTTP::Get.new(uri.request_uri)
    request.basic_auth($username, $password)
    Net::HTTP.start(uri.host, uri.port) do |http|
      http.read_timeout = 45
      response = http.request(request)
      open(target, "wb") do |file|
        file.write(response.body)
      end
    end
  end
end

class ApplianceHandler < CommandHandler
  def self.list_appliances
    r = Request.new
    r.method = "GET"
    r.call = "appliances"
    s = doRequest(r)

    xml = XML::Smart.string( s )
    res = String.new
    xml.find("/appliances/appliance").each do |a|
      res << "#{a.find("id").first.to_s}: #{a.find("name").first.to_s} (based on #{a.find("basesystem").first.to_s})\n"
      res << "  Cloned from: #{a.find("parent/name").first.to_s} (#{a.find("parent/id").first.to_s})\n" unless a.find("parent/name").length == 0
      res << "  Builds:      #{a.find("builds/build").length} (#{a.find("builds/build/compressed_image_size").inject(0){|sum,item| sum + item.to_i}})\n"
      res << "\n"
    end
    puts res
  end

  def self.clone_appliance args
    clonefrom = args[1]
    if clonefrom.nil? || clonefrom.empty?
      STDERR.puts "You need to specify a template."
      exit 1
    end
    r = Request.new
    r.method = "POST"
    r.call = "appliances?clone_from=#{clonefrom}"
    s = doRequest(r)

    xml = XML::Smart.string( s )
    res = String.new
    res << "Created Appliance: #{xml.find("/appliance/name").first.to_s}\n"
    res << "  Id:          " + xml.find("/appliance/id").first.to_s + "\n"
    res << "  Based on:    " + xml.find("/appliance/basesystem").first.to_s + "\n"
    res << "  Cloned from: #{xml.find("/appliance/parent/name").first.to_s} (#{xml.find("/appliance/parent/id").first.to_s})\n" unless xml.find("/appliance/parent/name").length == 0
    puts res
  end

  def self.delete_appliance args
    appliance = get_appliance_from_args_or_config args
    r = Request.new
    r.method = "DELETE"
    r.call = "appliances/#{appliance}"
    doRequest(r)
    puts "Success."
  end

  def self.template_sets
    r = Request.new
    r.method = "GET"
    r.call = "template_sets"
    s = doRequest(r)
    
    xml = XML::Smart.string( s )
    res = String.new
    xml.find("/template_sets/template_set").each do |ts|
      res << "'#{ts.find("name").first.to_s}' Templates (#{ts.find("description").first.to_s}):\n"
      ts.find("template").each do |t|
        res << " #{t.find("appliance_id").first.to_s}: #{t.find("name").first.to_s} (based on #{t.find("basesystem").first.to_s})\n"
        res << "    Description: #{t.find("description").first.to_s}\n\n"
      end
    end
    puts res
  end
end


class BuildHandler < CommandHandler
  def self.build_appliance args, force
    appliance = get_appliance_from_args_or_config args
    r = Request.new
    r.method = "POST"
    r.call = "running_builds?appliance_id=#{appliance}"
    r.call += "&force=1" if force
    s = doRequest(r)

    xml = XML::Smart.string( s )
    res = String.new
    res << "Triggered build: #{xml.find("/build/id").first.to_s}" unless xml.find("/build/id").length == 0
    puts res
  end

  def self.list_running_builds args
    appliance = get_appliance_from_args_or_config args
    r = Request.new
    r.method = "GET"
    r.call = "running_builds/?appliance_id=#{appliance}"
    s = doRequest(r)

    xml = XML::Smart.string( s )
    res = String.new
    xml.find("/running_builds/running_build").each do |rb|
      res << "#{rb.find("id").first.to_s}: #{rb.find("state").first.to_s}"
      res << ", #{rb.find("percent").first.to_s}% done - #{rb.find("message").first.to_s} (#{rb.find("time_elapsed").first.to_s}s elapsed)" unless xml.find("state").first.to_s == "error"
    end
    puts res unless res.empty?
  end
  
  def self.show_running_build args, follow
    build = args[1]
    if build.nil? || build.empty?
      STDERR.puts "You need to specify a running build."
      exit 1
    end
    r = Request.new
    r.method = "GET"
    r.call = "running_builds/#{build}"
    while 1
      s = doRequest(r)

      xml = XML::Smart.string( s )
      res = String.new
      return unless xml.find("/running_build/id").length > 0
      res << xml.find("/running_build/state").first.to_s
      res << ", #{xml.find("/running_build/percent").first.to_s}% done - #{xml.find("/running_build/message").first.to_s} (#{xml.find("/running_build/time_elapsed").first.to_s}s elapsed)" unless xml.find("/running_build/state").first.to_s == "error"
      puts res
      exit 0 unless follow
      sleep 5
    end
  end

  def self.list_builds args
    appliance = get_appliance_from_args_or_config args
    r = Request.new
    r.method = "GET"
    r.call = "builds/?appliance_id=#{appliance}"
    s = doRequest(r)

    xml = XML::Smart.string( s )
    res = String.new
    xml.find("/builds/build").each do |rb|
      res << "#{rb.find("id").first.to_s}: #{rb.find("state").first.to_s}"
      res << ", v#{rb.find("version").first.to_s} (#{rb.find("image_type").first.to_s})"
      res <<  " (#{rb.find("compressed_image_size").first.to_s} MB)" if rb.find("compressed_image_size").length > 0
      res << " #{rb.find("download_url").first.to_s}" if rb.find("download_url").length > 0
      res << "\n"
    end
    puts res unless res.empty?
  end

  def self.show_build args
    build = args[1]
    if build.nil? || build.empty?
      STDERR.puts "You need to specify a build."
      exit 1
    end
    r = Request.new
    r.method = "GET"
    r.call = "builds/#{build}"
    s = doRequest(r)

    xml = XML::Smart.string( s )
    res = String.new
    xml.find("/build").each do |rb|
      res << "#{rb.find("id").first.to_s}: #{rb.find("state").first.to_s}"
      res << ", v#{rb.find("version").first.to_s} (#{rb.find("image_type").first.to_s})"
      res <<  " (#{rb.find("size").first.to_s}/#{rb.find("compressed_image_size").first.to_s} MB)" if rb.find("size").length > 0
      res << " #{rb.find("download_url").first.to_s}" if rb.find("download_url").length > 0
    end
    puts res unless res.empty?
  end

  def self.cancel_build args
    build = args[1]
    if build.nil? || build.empty?
      STDERR.puts "You need to specify a build."
      exit 1
    end
    r = Request.new
    r.method = "DELETE"
    r.call = "running_builds/#{build}"
    doRequest(r)
    puts "Success."
  end

  def self.delete_build args
    build = args[1]
    if build.nil? || build.empty?
      STDERR.puts "You need to specify a build."
      exit 1
    end
    r = Request.new
    r.method = "DELETE"
    r.call = "builds/#{build}"
    doRequest(r)
    puts "Success."
  end
end


class CheckoutHandler < CommandHandler
  def self.checkout args, images
    appliance = get_appliance_from_args_or_config args
    # Get appliance
    r = Request.new
    r.method = "GET"
    r.call = "appliances/#{appliance}"
    s = doRequest(r)
    appliancexml  =XML::Smart.string( s )
    id = appliancexml.find("appliance/id").first.to_s
    base_system = appliancexml.find("appliance/basesystem").first.to_s
    puts "Checkout '#{appliancexml.find("appliance/name").first.to_s}'\n"

    FileUtils.mkdir_p id
    [ ".ssc", ".ssc/files", ".ssc/rpms", "files", "rpms", "images"].each do |d|
      FileUtils.mkdir_p id + "/" + d
    end

    XML::Smart.modify("#{id}/.ssc/appliance.config","<checkout/>") { |doc|
      node = doc.root.add("appliance_id", id)
      node = doc.root.add("appliance_name", appliancexml.find("appliance/name").first.to_s)
      node = doc.root.add("base_system", appliancexml.find("appliance/base_system").first.to_s)
    }

    # Get files
    r = Request.new
    r.method = "GET"
    r.call = "files/?appliance_id=#{appliance}"
    s = doRequest(r)

    filesxml = XML::Smart.string( s )
    filesxml.find("files/file").each do |f|
      filename = f.find("filename").first.to_s
      fileid = f.find("id").first.to_s
      path = "#{id}/files/#{filename}"
      puts "  Downloading '#{filename}'"

      download_file "http://#{$server_name}/#{$api_prefix}/files/#{fileid}/data", path
      FileUtils.cp path, "#{id}/.ssc/files/#{filename}.orig"
      download_file "http://#{$server_name}/#{$api_prefix}/files/#{fileid}", "#{id}/.ssc/files/#{filename}.config"
      XML::Smart.modify("#{id}/.ssc/files/#{filename}.config") do |doc|
        node = doc.find("/file").first
        node.add("state", "synched")
      end
    end

    # Get rpms
    r = Request.new
    r.method = "GET"
    r.call = "rpms?base_system=#{base_system}"
    s = doRequest(r)

    rpmsxml = XML::Smart.string( s )
    rpmsxml.find("rpms/rpm").each do |rpm|
      filename = rpm.find("filename").first.to_s
      fileid = rpm.find("id").first.to_s
      path = "#{id}/rpms/#{filename}"
      puts "  Downloading '#{filename}'"
      
      download_file "http://#{$server_name}/#{$api_prefix}/rpms/#{fileid}/data", path
      FileUtils.cp path, "#{id}/.ssc/rpms/#{filename}.orig"
      download_file "http://#{$server_name}/#{$api_prefix}/rpms/#{fileid}", "#{id}/.ssc/rpms/#{filename}.config"
      XML::Smart.modify("#{id}/.ssc/rpms/#{filename}.config") do |doc|
        node = doc.find("/rpm").first
        node.add("state", "synched")
      end
    end

    if images
      appliancexml.find("appliance/builds/build").each do |build|
        url = build.find("download_url").first.to_s
        puts "  Downloading image '#{File.basename(url)}'"
        download_file url, "#{id}/images/#{File.basename(url)}"
      end
    else
      puts "  Skipped downloading images (change with -i)'"
    end
  end

  def self.status
    appliance_config = XML::Smart.open(".ssc/appliance.config")
    id = appliance_config.find("/checkout/appliance_id").first.to_s
    name = appliance_config.find("/checkout/appliance_name").first.to_s

    show_files = false
    unknown_files = Array.new
    added_files = Array.new
    modified_files = Array.new
    removed_files = Array.new
    Dir.entries("files").each do |file|
      if [".", ".."].include?(file) then next end
      if File.exists?(".ssc/files/#{file}.config")
        xml = XML::Smart.open(".ssc/files/#{file}.config")
        status = xml.find("file/state").first.to_s
        if status == "added"
          added_files << file
          show_files = true
        elsif status == "synched"
          oldmd5 = `md5sum .ssc/files/#{file}.orig`.split[0]
          md5 = `md5sum files/#{file}`.split[0]
          if md5 == oldmd5
            next
          elsif md5 != oldmd5
            modified_files << file
            show_files = true
          end
        end
      else
          unknown_files << file
          show_files = true
      end
    end
    Dir.entries(".ssc/files").each do |file|
      if [".", ".."].include?(file) then next end
      unless file =~ /.*.config$/ then next end
      xml = XML::Smart.open(".ssc/files/#{file}")
      if xml.find("file/state").first.to_s == "removed"
        removed_files << file.sub(/(.*).config$/, "\\1")
        show_files = true
      end
    end

    show_rpms = false
    unknown_rpms = Array.new
    added_rpms = Array.new
    modified_rpms = Array.new
    removed_rpms = Array.new
    Dir.entries("rpms").each do |file|
      if [".", ".."].include?(file) then next end
      if File.exists?(".ssc/rpms/#{file}.config")
        xml = XML::Smart.open(".ssc/rpms/#{file}.config")
        status = xml.find("rpm/state").first.to_s
        if status == "added"
          added_rpms << file
          show_rpms = true
        elsif status == "synched"
          oldmd5 = `md5sum .ssc/rpms/#{file}.orig`.split[0]
          md5 = `md5sum rpms/#{file}`.split[0]
          if md5 == oldmd5
            next
          elsif md5 != oldmd5
            modified_rpms << file
            show_rpms = true
          end
        end
      else
          unknown_rpms << file
          show_rpms = true
      end
    end
    Dir.entries(".ssc/rpms").each do |file|
      if [".", ".."].include?(file) then next end
      unless file =~ /.*.config$/ then next end
      xml = XML::Smart.open(".ssc/rpms/#{file}")
      if xml.find("rpm/state").first.to_s == "removed"
        removed_rpms << file.sub(/(.*).config$/, "\\1")
        show_rpms = true
      end
    end

    puts "Status of #{name} (#{id}):"
    if show_files
      puts " Overlay files:"
      unknown_files.each {|f| puts "   ? #{f}"}
      modified_files.each {|f| puts "   M #{f}"}
      added_files.each {|f| puts "   A #{f}"}
      removed_files.each {|f| puts "   D #{f}"}
    end
    if show_rpms
      puts " RPMs:"
      unknown_rpms.each {|f| puts "   ? #{f}"}
      modified_rpms.each {|f| puts "   M #{f}"}
      added_rpms.each {|f| puts "   A #{f}"}
      removed_rpms.each {|f| puts "   D #{f}"}
    end
    unless show_files or show_rpms
      puts "Nothing changed."
    end
  end

  def self.commit
    appliance = get_appliance_from_args_or_config nil
    appliance_config = XML::Smart.open(".ssc/appliance.config")
    base = appliance_config.find("checkout/base_system").first.to_s

    Dir.entries(".ssc/rpms").each do |file|
      next unless file =~ /.config$/
      config = XML::Smart.open(".ssc/rpms/" + file)
      filename = file.gsub(/(.*).config$/, "\\1")
      status = config.find("rpm/state").first.to_s

      if (status == "added")
        puts "Uploading #{filename}"
        s = `curl -u #{$username}:#{$password} -XPOST -F\"file=@#{"rpms/" + filename}\" http://#{$username}:#{$password}@#{$server_name}/#{$api_prefix}/rpms?base_system=#{base}`
        xml = XML::Smart.string(s)
        id = xml.find("file/id").first.to_s unless xml.find("file/id").length == 0
        if id
          FileUtils.cp "files/#{filename}", ".ssc/rpms/#{filename}.orig"
          download_file "http://#{$server_name}/#{$api_prefix}/rpms/#{id}", ".ssc/rpms/#{filename}.config"
        end
      elsif (status == "removed")
        puts "Removing #{filename}"
        id = config.find("rpm/id").first.to_s
        r = Request.new
        r.method = "DELETE"
        r.call = "rpms/#{id}"
        doRequest(r)
      else
        oldmd5 = `md5sum .ssc/rpms/#{filename}.orig`.split[0]
        md5 = `md5sum rpms/#{filename}`.split[0]
        if (status == "synched" and md5 != oldmd5)
          id = config.find("rpm/id").first.to_s
          puts "Updating #{filename}"
          `curl -u #{$username}:#{$password} -XPUT -F\"file=@#{"rpms/" + filename}\" http://#{$username}:#{$password}@#{$server_name}/#{$api_prefix}/rpms/#{id}/data 2> /dev/null`
          download_file "http://#{$server_name}/#{$api_prefix}/rpms/#{id}", ".ssc/rpms/#{filename}.config"
        end
      end
    end
    Dir.entries(".ssc/files").each do |file|
      next unless file =~ /.config$/
      config = XML::Smart.open(".ssc/files/" + file)
      filename = file.gsub(/(.*).config$/, "\\1")
      status = config.find("file/state").first.to_s

      if (status == "added")
        puts "Uploading #{filename}"
        s = `curl -u #{$username}:#{$password} -XPOST -F\"file=@#{"files/" + filename}\" http://#{$username}:#{$password}@#{$server_name}/#{$api_prefix}/files?appliance_id=#{appliance} 2> /dev/null`
        xml = XML::Smart.string(s)
        id = xml.find("file/id").first.to_s unless xml.find("file/id").length == 0
        if id
          FileUtils.cp "files/#{filename}", ".ssc/files/#{filename}.orig"
          download_file "http://#{$server_name}/#{$api_prefix}/files/#{id}", ".ssc/files/#{filename}.config"
        end
      elsif (status == "removed")
        puts "Removing #{filename}"
        id = config.find("file/id").first.to_s
        r = Request.new
        r.method = "DELETE"
        r.call = "files/#{id}"
        doRequest(r)
        FileUtils.rm ".ssc/files/#{filename}.orig"
        FileUtils.rm ".ssc/files/#{filename}.config"
      else
        oldmd5 = `md5sum .ssc/files/#{filename}.orig`.split[0]
        md5 = `md5sum files/#{filename}`.split[0]
        if ((status == "synched" or status == "modified") and md5 != oldmd5)
          id = config.find("file/id").first.to_s
          puts "Updating #{filename}"
          `curl -u #{$username}:#{$password} -XPUT -F\"file=@#{"files/" + filename}\" http://#{$username}:#{$password}@#{$server_name}/#{$api_prefix}/files/#{id}/data 2> /dev/null`
          download_file "http://#{$server_name}/#{$api_prefix}/files/#{id}", ".ssc/files/#{filename}.config"
        end
      end
    end
  end

  def self.add args
    filename = args[1]
    unless File.exists?(filename)
      STDERR.puts "File '#{filename}' does not exist."
      return 1
    end
    f = File.open(filename)
    path = File.expand_path(filename)
    basename = File.basename(path)
    if path =~ /.*\/rpms\/#{basename}/
      XML::Smart.modify(".ssc/rpms/#{basename}.config","<rpm/>") { |doc|
        node = doc.root.add("state", "added")
      }
    elsif path =~ /.*\/files\/#{basename}/
      XML::Smart.modify(".ssc/files/#{basename}.config","<file/>") { |doc|
        node = doc.root.add("state", "added")
      }
    else
      STDERR.puts "Only files in /rpms and /files can be added."
      return 1
    end
  end

  def self.remove args
    filename = args[1]
    path = File.expand_path(filename)
    basename = File.basename(path)
    if path =~ /.*\/rpms\/#{basename}/
      type = "rpm"
    elsif path =~ /.*\/files\/#{basename}/
      type = "file"
    else
      STDERR.puts "Only files in /rpms and /files can be removed."
      return 1
    end
    unless File.exists?(".ssc/#{type}s/#{basename}.config")
      STDERR.puts "The file does not belong to the checkout and can not be removed."
      return 1
    end

    XML::Smart.modify(".ssc/#{type}s/#{basename}.config") { |doc|
      nodes = doc.find("#{type}/state")
      nodes.delete_at!(0)
      doc.root.add("state", "removed")
    }
    FileUtils.rm filename
  end

end










opt = OptionParser.new
opt.separator("Options")
opt.on( "-s", "--server", "=HOST",
  "The Studio hostname" ) do |v|
  $server_name = v
end
opt.on( "-u", "--username", "=USER_NAME", "User name") do |v|
  $username = v
end
opt.on( "-p", "--password", "=PASSWORD", "Password") do |v|
  $password = v
end
opt.on( "-h", "--help", "Print this message" ) do
  puts opt
  exit
end
opt.on( "-v", "--version",  "Print the version") do |v|
  puts "ssc #{version} - A command line interface to SUSE Studio"
  exit 0
end


if ARGV.include?("ba") || ARGV.include?("buildappliance")
  opt.banner = "Usage: ssc [options] buildappliance APPLIANCE [command-options]"
  opt.separator("Trigger a build of an appliance.")
  opt.separator("\n")
  opt.separator("Command options:")
  opt.on( "-f", "--force","Force building the appliance even if it overwrites a build") do |v|
    force = v
  end
elsif ARGV.include?("la") || ARGV.include?("listappliances")
  opt.banner = "Usage: ssc [options] listappliances"
  opt.separator("Show a list of your appliances.")
elsif ARGV.include?("ca") || ARGV.include?("cloneappliance")
  opt.banner = "Usage: ssc [options] cloneappliance APPLIANCE"
  opt.separator("Create a new appliance by cloning a template.")
elsif ARGV.include?("da") || ARGV.include?("deleteappliance")
  opt.banner = "Usage: ssc [options] deleteappliance APPLIANCE"
  opt.separator("Delete an appliance.")
elsif ARGV.include?("lt") || ARGV.include?("listtemplates")
  opt.banner = "Usage: ssc [options] listtemplates"
  opt.separator("Get a list of available templates.")
elsif ARGV.include?("lrb") || ARGV.include?("listrunningbuilds")
  opt.banner = "Usage: ssc [options] listrunningbuilds APPLIANCE"
  opt.separator("List all running builds of an appliance.")
elsif ARGV.include?("srb") || ARGV.include?("showrunningbuild")
  opt.banner = "Usage: ssc [options] showrunningbuild ID"
  opt.separator("Show the status of a running build.")
  opt.on( "-f", "--follow","Follow the progress of the build") do |f|
    follow = f
  end
elsif ARGV.include?("lb") || ARGV.include?("listbuilds")
  opt.banner = "Usage: ssc [options] listbuilds APPLIANCE"
  opt.separator("List builds of an appliance.")
elsif ARGV.include?("sb") || ARGV.include?("showbuild")
  opt.banner = "Usage: ssc [options] showbuild ID"
  opt.separator("Show information on a build.")
elsif ARGV.include?("cb") || ARGV.include?("cancelbuild")
  opt.banner = "Usage: ssc [options] cancelbuild ID"
  opt.separator("Cancel a running build.")
elsif ARGV.include?("db") || ARGV.include?("deletebuild")
  opt.banner = "Usage: ssc [options] deletebuild ID"
  opt.separator("Delete a finished build.")
elsif ARGV.include?("co") || ARGV.include?("checkout")
  opt.banner = "Usage: ssc [options] checkout APPLIANCE"
  opt.separator("Checkout an appliance.")
  opt.on( "-i", "--download-images","Download images of the appliance") do |i|
    images = i
  end
elsif ARGV.include?("st") || ARGV.include?("status")
  opt.banner = "Usage: ssc [options] status"
  opt.separator("Show the status of the checkout.")
elsif ARGV.include?("ci") || ARGV.include?("commit")
  opt.banner = "Usage: ssc [options] commit"
  opt.separator("Commit changes to the appliance.")
elsif ARGV.include?("add")
  opt.banner = "Usage: ssc [options] add FILE"
  opt.separator("Add a file to the checkout.")
elsif ARGV.include?("rm") || ARGV.include?("remove")
  opt.banner = "Usage: ssc [options] remove FILE"
  opt.separator("Remove a file from the checkout.")
else
  opt.banner = "Usage: ssc [options] COMMAND [command-options]"
  opt.separator("SUSE Studio command line client.")
  opt.separator("Type 'ssc COMMAND --help' for help on a specific command.")

  opt.separator("\n")
  opt.separator("Commands:")
  opt.separator("    Managing your appliances:")
  opt.separator("      listappliances,la\t\t     Get a list of your appliances")
  opt.separator("      cloneappliance,ca\t\t     Create a new appliance by cloning a template")
  opt.separator("      deleteappliance,da\t     Delete an appliance")
  opt.separator("      listtemplates,lt\t\t     Get a list of available templates")
  opt.separator("\n")
  opt.separator("    Managing builds:")
  opt.separator("      buildappliance,ba\t\t     Trigger a build of an appliance")
  opt.separator("      listrunningbuilds,lrb\t     List all running builds of an appliance")
  opt.separator("      showrunningbuild,srb\t     Show the status of a running build")
  opt.separator("      listbuilds,lb\t\t     List builds of an appliance")
  opt.separator("      showbuild,sb\t\t     Show information on a build")
  opt.separator("      cancelbuild,cb\t\t     Cancel a running build")
  opt.separator("      deletebuild,db\t\t     Delete a finished build")
  opt.separator("\n")
  opt.separator("    Managing checkouts:")
  opt.separator("      checkout,co\t\t     Checkout an appliance")
  opt.separator("      status,st\t\t\t     Show the status of the checkout")
  opt.separator("      commit,ci\t\t\t     Commit changes to the appliance")
  opt.separator("      add\t\t\t     Add a file to the checkout")
  opt.separator("      rm\t\t\t     Remove a file from the checkout")
  opt.separator("\n")
end

begin
  opt.parse!( ARGV )
rescue OptionParser::InvalidOption
  STDERR.puts $!
  STDERR.puts opt
  exit 1
end

if ARGV.size == 0
  STDERR.puts opt
  exit 1
end

cmd = ARGV[0]

if cmd == "listappliances" or cmd =="la"
  ApplianceHandler.list_appliances

elsif cmd == "cloneappliance" or cmd =="ca"
  ApplianceHandler.clone_appliance ARGV

elsif cmd == "deleteappliance" or cmd == "da"
  ApplianceHandler.delete_appliance ARGV

elsif cmd == "listtemplates" or cmd =="lt"
  ApplianceHandler.template_sets

elsif cmd == "buildappliance" or cmd =="ba"
  BuildHandler.build_appliance ARGV, force

elsif cmd == "listrunningbuilds" or cmd =="lrb"
  BuildHandler.list_running_builds ARGV

elsif cmd == "showrunningbuild" or cmd =="srb"
  BuildHandler.show_running_build ARGV, follow

elsif cmd == "listbuilds" or cmd =="lb"
  BuildHandler.list_builds ARGV

elsif cmd == "showbuild" or cmd =="sb"
  BuildHandler.show_build ARGV

elsif cmd == "cancelbuild" or cmd =="cb"
  BuildHandler.cancel_build ARGV

elsif cmd == "deletebuild" or cmd =="db"
  BuildHandler.delete_build ARGV

elsif cmd == "checkout" or cmd =="co"
  CheckoutHandler.checkout ARGV, images

elsif cmd == "status" or cmd =="st"
  CheckoutHandler.status

elsif cmd == "commit" or cmd =="ci"
  CheckoutHandler.commit

elsif cmd == "add"
  CheckoutHandler.add ARGV

elsif cmd == "remove" or cmd == "rm"
  CheckoutHandler.remove ARGV

else
  STDERR.puts "Unknown command: #{cmd}\n"
  STDERR.puts opt
  exit 1
end
